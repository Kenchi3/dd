wait(5)
-- Auto Dungeon Script

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- Global control variables
_G.AutoDungeonEnabled = true -- ใช้สำหรับเปิด/ปิดการทำงานของสคริปต์
_G.Dungeon = "DoubleDungeonD" -- ชื่อดันเจี้ยนที่ต้องการเลือก
_G.DungeonDifficulty = "Nightmare" -- ความยากที่ต้องการเลือก
_G.WaitTimes = {
    LobbyCreation = 2,
    DifficultySelection = 2,
    LobbyStart = 5,
    DungeonStart = 10,
    ReturnToLobby = 5
}
_G.InDungeon = false -- ใช้เก็บสถานะว่าผู้เล่นอยู่ในดันเจี้ยนหรือไม่

-- Function to wait for a specific time
local function waitFor(seconds)
    local start = os.clock()
    while os.clock() - start < seconds do
        task.wait()
    end
end

-- Function to check if the player is in the dungeon
local function isInDungeon()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if gui then
        local screenGui = gui:FindFirstChild("ScreenGui")
        if screenGui then
            local startDungeonFolder = screenGui:FindFirstChild("StartDungeon") -- เข้าถึงโฟลเดอร์ StartDungeon
            if startDungeonFolder then
                local startDungeonButton = startDungeonFolder:FindFirstChild("StartDungeon") -- เข้าถึงปุ่ม StartDungeon ตัวที่สอง
                if startDungeonButton then
                    print("StartDungeon button found. Visible:", startDungeonButton.Visible)
                    return startDungeonButton.Visible -- ใช้ Visible เพื่อบอกสถานะ
                else
                    print("StartDungeon button not found in StartDungeon folder.")
                end
            else
                print("StartDungeon folder not found in ScreenGui.")
            end
        else
            print("ScreenGui not found in PlayerGui.")
        end
    else
        print("PlayerGui not found.")
    end
    return false -- หากไม่พบ GUI ให้ถือว่าอยู่ในล๊อบบี้
end

-- Function to check if the dungeon has ended
local function isDungeonEnded()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if gui then
        local screenGui = gui:FindFirstChild("ScreenGui")
        local dungeonEnd = screenGui and screenGui:FindFirstChild("DungeonEnd")
        local leaveButton = dungeonEnd and dungeonEnd:FindFirstChild("Leave")
        if leaveButton and leaveButton.Visible then
            return true -- ดันเจี้ยนจบแล้ว
        end
    end
    return false -- ดันเจี้ยนยังไม่จบ
end

-- เพิ่มตัวแปรเพื่อจัดการสถานะการกลับไปที่ล๊อบบี้
local returningToLobby = false

-- Listen for DungeonEnded Remote Event
local dungeonEnded = false
Remotes:WaitForChild("DungeonEnded").OnClientEvent:Connect(function(dungeonName, difficulty, isVictory, ...)
    print("DungeonEnded Event Triggered!")
    print("Dungeon Name:", dungeonName)
    print("Difficulty:", difficulty)
    print("Victory:", isVictory)

    -- พิมพ์ข้อความเพื่อบอกว่าดันเจี้ยนจบแล้ว
    if isVictory then
        print("Dungeon completed successfully!")
    else
        print("Dungeon failed.")
    end

    -- ตั้งสถานะว่าดันเจี้ยนจบแล้ว
    dungeonEnded = true
end)

-- Main loop
while _G.AutoDungeonEnabled do
    if not isInDungeon() and not returningToLobby then
        -- In Lobby
        print("Currently in Lobby.")

        -- Step 1: Create Lobby
        local createLobbyArgs = {
            [1] = _G.Dungeon -- ใช้ค่าจาก _G.Dungeon
        }
        Remotes:WaitForChild("createLobby"):InvokeServer(unpack(createLobbyArgs))
        print("Lobby created for dungeon: " .. _G.Dungeon)
        waitFor(_G.WaitTimes.LobbyCreation)

        -- Step 2: Select Difficulty
        local difficultyArgs = {
            [1] = _G.DungeonDifficulty -- ใช้ค่าจาก _G.DungeonDifficulty
        }
        Remotes:WaitForChild("LobbyDifficulty"):FireServer(unpack(difficultyArgs))
        print("Difficulty selected: " .. _G.DungeonDifficulty)
        waitFor(_G.WaitTimes.DifficultySelection)

        -- Step 3: Start Lobby
        Remotes:WaitForChild("LobbyStart"):FireServer()
        print("Lobby started.")
        waitFor(_G.WaitTimes.LobbyStart)
    elseif isInDungeon() then
        -- In Dungeon
        print("Currently in Dungeon.")

        -- Step 4: Start Dungeon
        Remotes:WaitForChild("DungeonStart"):FireServer()
        print("Dungeon started.")
        waitFor(_G.WaitTimes.DungeonStart)

        -- Step 5: Wait for DungeonEnded Event
        print("Waiting for dungeon to end...")
        dungeonEnded = false -- รีเซ็ตสถานะก่อนรอ Remote Event
        repeat
            waitFor(1) -- รอ 1 วินาทีแล้วตรวจสอบอีกครั้ง
        until dungeonEnded

        -- Step 6: Return to Lobby
        print("Dungeon has ended. Returning to lobby...")
        returningToLobby = true -- ตั้งสถานะว่ากำลังกลับไปที่ล๊อบบี้
        Remotes:WaitForChild("LeaveToLobby"):FireServer()
        waitFor(_G.WaitTimes.ReturnToLobby) -- รอให้กลับไปที่ล๊อบบี้
        returningToLobby = false -- รีเซ็ตสถานะเมื่อกลับถึงล๊อบบี้
    end
end


--—————— Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")


local Player = Players.LocalPlayer
local Char =  Player.Character or Player.CharacterAdded:Wait()
local rootpart : BasePart = Char:FindFirstChild("HumanoidRootPart")
local hum : Humanoid = Char:FindFirstChild("Humanoid")






local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
	Title = "Fluent " .. Fluent.Version,
	SubTitle = "by dawid",
	TabWidth = 160,
	Size = UDim2.fromOffset(580, 460),
	Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
	Theme = "Dark",
	MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
	Main = Window:AddTab({ Title = "Main", Icon = "" }),
	Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options




local test = 15
local test1 = false
do
	task.spawn(function()
		while true do

			if test1 then
				local Combat_upvr = game:GetService("ReplicatedStorage").Remotes.Combat

				Combat_upvr:FireServer()

				for _,v in workspace:FindFirstChild("Mobs"):GetDescendants() do
					if v:IsA("Humanoid") and v.Parent:FindFirstChild("HumanoidRootPart") and v.Parent.Name ~= Char.Name then
						rootpart.CFrame = v.Parent:FindFirstChild("HumanoidRootPart").CFrame * CFrame.new(0,test,0) * CFrame.Angles(math.rad(-90),0,0)
					end
				end
			end

			task.wait()
		end

	end)
end

do



	local Toggle = Tabs.Main:AddToggle("MyToggle", {Title = "Toggle", Default = true })

	Toggle:OnChanged(function()
		test1 = Options.MyToggle.Value
	end)

	Options.MyToggle:SetValue(false)



	local Slider = Tabs.Main:AddSlider("Slider", {
		Title = "Slider",
		Description = "This is a slider",
		Default = 2,
		Min = 11,
		Max = 20,
		Rounding = 1,
		Callback = function(Value)
			test = Value
		end
	})

end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
	Title = "Fluent",
	Content = "The script has been loaded.",
	Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
